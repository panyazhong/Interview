## http2 多路复用

http1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手和 4 次握手，这个过程在一次请求过程中占用了较长的时间，即使开始 keep-alive，解决了多次连接的问题但依然存在两个效率上的问题，一是串行的文件输出，而是连接过多导致的性能问题。

http/2 的多路复用就是为了解决上述两个问题。

在 http/2 中，有两个非常重要的改名，帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就在一个 TCP 连接中可以存在多条流。换句话说。也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 http 旧版本中的队头阻塞问题，极大地提高传输性能。

### 三次握手 四次握手

三次握手就是指建立一个 TCP 连接是，客户端和服务端总共发送 3 个包。进行三次握手的主要作用是确认双方的接受能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上其实就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换<code>TCP 窗口大小</code>信息

刚开始客户端出去 Closed 状态，服务端处于 Listen 状态。

- 第一次握手：客户端给服务端发送一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于<code>SYN_SEND</code>状态

  首部的同步位 SYN = 1，初始序号 seq = x, SYN = 1 的报文段不能携带数据，但消耗一个序号

- 第二次握手：服务端收到 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于<code>SYN_RCVD</code>

  在确认报文段中 SYN = 1，ACK = 1，确认号 ack = x + 1，初始序号 seq =y。

- 第三次握手：客户端收到 SYN 报文后，会发送一个 ACK 报文，当然，也是一样把服务端的 ISN + 1 作为 ACK 的值，表示已经接收到了服务端的 SYN 报文，只是客户端处于<code>ESTABLISHED</code>状态。服务端在收到 ACK 报文之后，也处于<code>ESTABLISHED</code>状态，双方建立连接

  确认报文 ACK = 1，确认号 ack = y + 1，序号 seq = x + 1（初始为 seq= x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。

发送第一个 SYN 的一端将执行主动打开（active open），接收这个 SYN 并发回下一个 SYN 的另一端执行被动打开（passive open）

### 半连接队列

服务器第一次收到 SYN 报文，服务端处于 SYN_RCVD 状态，双方还未建立连接，服务端会把这个状态下的请求放在一个<strong>队列</strong>中，称之为<strong>半连接队列</strong>

<strong>全连接队列</strong>，就是已完成三次握手的连接会存放到一个队列中，成为全连接队列，如果队列满了就可能出现丢包的现象

关于 SYN-ACK 重传次数的问题，当服务端发送了 SYN-ACK 包后，如果未收到客户端的的确认包，服务端进行首次重传，等待一段时间如果还未收到就进行第二次重传，知道次数超过系统规定的最大重传次数，会将半连接状态从队列中删除。一般重传间隔按指数增长，1s，2s，4s，8s...

### ISN(Initial Sequence Number)是固定的吗？

ISN 不是固定的，是随时间变化的，因此每次连接的 ISN 都是不同的。

为什么不同呢？如果每次请求的 ISN 相同，那么攻击者很容易猜出后续的确认号，达到攻击目的

### 三次握手可以携带数据吗？

三次握手的第一次和第二次是不可以携带数据的，第三次握手可以携带数据。

如果第一次握手就可以携带数据，攻击者可以在 SYN 报文中携带大量数据，从而让服务器花费大量时间、空间接收报文。

### SYN 攻击是什么？

服务端的资源分配实在第二次握手的时候，而客户端的资源分配则是在第三次握手完成后进行的。SYN 攻击就是随机产生大量的 IP 地址向服务器发生请求，服务器发生报文后，无法接收到客户端的确认包，从而不断地重发请求，导致半连接队列被沾满，而正常的请求会被丢弃，引起网络拥挤甚至瘫痪，即常说的 DOS/DDOS 攻击。

## 四次挥手（四次握手）

由 TCP 的<strong>半关闭</strong>（half-close）造成的。

半关闭，就是 TCP 提供了连接的一端在结束它的发送后还能接收来自另一端的数据的能力。

TCP 连接的拆除需要发送四个包，因此需要四次挥手（Four-way handshake）。服务端和客户端都可以发起挥手动作。

- 第一次挥手：客户端如果想断开连接，发送 FIN=1 的报文，同事发送 seq=u 的初始序号，客户端进入 FIN_WAIT1 状态。

- 第二次挥手：服务端接收到客户端的断开请求，发送 ACK=1 的报文报文，将 u+1 作为确认号 ack 的值，并且发送自己的序号 seq=v。此时服务器进入 CLOSE_WAIT 状态。客户端在接收到服务器的确认后，进入到 FIN_WIAT2 状态。

- 第三次挥手：服务端想断开连接，发送 FIN=1 的报文，指定一个序号 seq=w，服务端处于 LAST_ACK（最后确认）状态，即服务端没有要向客户端发送的数据，服务端发出连接释放报文端（FIN=1，ACK=1，seq=w，ack=u+1）

- 第四次挥手：客户端在接收到 FIN 报文后，发送一个 ACK=1 的报文，将 w+1 作为确认号 ack 的值发送，同时发送 seq=u+1 的序号，客户端进入 TIME_WAIT 状态。需要过一段时间（计时器设置的 2MSL）确保服务端收到 ACK 请求后客户端进入 CLOSED 状态。服务端在接收到 ACK 请求后，就处于 CLOSED 状态。

四次挥手客户端会从 FIN_WAIT1 -> FIN_WAIT2 -> TIME_WAIT -> CLOSED

服务端 CLOSE_WAIT -> LAST_ACK -> CLOSED

### 为什么要四次挥手？

服务端在收到客户端的 FIN 报文后，并不会立即关闭 SOCKET，故而先发送 ACK=1 的报文告诉客户端 FIN 的已收到，需要等待服务器所有报文发送完毕，再发送 FIN 报文。

### 2MSL等待状态

TIME_WAIT也成为2MSL等待状态。

处理原则，当TCP执行一个主动关闭，并发挥最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL（最大存活时间 Maximum Segment Lifetime），确保可以让TCP再次发送最后的ACK以防ACK丢失

2MSL导致的结果就是在这段时间内，客户端IP和端口以及服务端的IP和端口不可再被使用。只有结束后才可以使用。


